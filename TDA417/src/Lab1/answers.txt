Task 1: figuring out the complexity
-----------------------------------

Insertion.java on:
  random inputs: n^2 in worst case, in average it's n(n+1)/2
  95% sorted inputs: Not linear, but close for small sizes. For larger sizes, it becomes quadratic.
  sorted inputs: linear complexity

Quick.java on:
  random inputs: On average, n*lg(n) complexity.
  95% sorted inputs: n*lg(n) complexity.
  sorted inputs: quadratic complexity. Assume array is sorted in ascending order, from 1 to n. First pivot element is the last element, say n. It then concludes that all elements to the left are on the "right side", but it doesn't know it's internal structure. So the pivot is its final position, and moves to n-1. This element does the same, all the way down to 2. So for element n there's n-1 accesses for the remaining elements + 1 for itself. -> We have n + (n-1) + ... + 3 + 2 + 1 = n*(n+1)/2 meaning quadratic complexity.

Merge.java on:
  random inputs: n*lg(n) complexity
  95% sorted inputs: n*lg(n) complexity
  sorted inputs: n*lg(n) complexity

Arrays.sort on:
  random inputs: n lg n
  95% sorted inputs: n*lg(n) complexity
  sorted inputs: linear complexity


Task 2: improving quicksort
---------------------------

Do the following changes affect the complexity of quicksort on any kind of
input data? If so, what is it that changes?

  Shuffling the array first: Yes, since we dont have any sorted array (or 95% sorted) we
  won't have as many partitions that will just remove one element at a time from the array.
  The "depth" of the splitting will not be "n" but instead "ln n". This changes the complexity
  from quadratic to linearithic.

  Median-of-three pivot selection: Yes, the reason here is similar to the shuffling.
  Before for the sorted arrays because we used the left most element as pivot and the partition
  would just be to remove one element, hence creating a quadratic complexity.
  Now we use the median of 3 elements instead of the left-most, hence doing more
  evenly partitions and creating a linear complexity for sorted arrays. Otherwise it is
  linerarethic.

  Insertion sort for small arrays (cutoff length = 50): For "small arrays" (sorted and 95%) the insertion sort
  on its own does not improve the performance if we straight up do the insertion sort without quicksort the
  performance is improved. But as soon as we get larger arrays the performance is untouched. For small sorted
  and 95% insertion sort has linear complexity.
  
Which combination of improvements gives the best result?

Using Median of 3 pivot alone yields the best results overall as mentioned above. Combining it with shuffling removes
the advantage of using this method. Since the method takes advantage of having an already
sorted array. So the combination of the two yields the same result as using shuffle alone. Combining "3-pivot" and
insertion sort yields really bad result for arrays of all sizes.

